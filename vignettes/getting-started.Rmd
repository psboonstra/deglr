---
title: "Getting started"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(deglr)
library(glmnet)
library(survival)
library(tidyverse)
library(knitr)
library(glue)
```

## Setup

Here we set the number of observations from the target and external populations
as well as the number of predictors. We will draw a large number of observations
from each but then demonstrate differences in performance with difference sample 
size ratios. 
```{r}
n_tar = 5000;
n_ext = 5000;
d = 3;
set.seed(1);
```

We will generate the predictors from multivariate normal distributions with mean
zero and covariance matrices sampled from a Wishart distribution. You can increase
the `wishart_precision` to force the diagonals closer to 1, and you can change
`correlation` to increase or decrease the correlation between predictors. You 
can change `scale_target` to modify the relative values of covariance matrices
between the populations; a value of 1 means they share the same covariance matrix;
a value less than 1 means that the target population has less variability. 

```{r}
wishart_precision = 10; 
correlation = 0.15
scale_target = 0.45;
cov_tar = rWishart(1, df = d * wishart_precision, (correlation + diag(1 - correlation, d)) / (d * wishart_precision))[, , 1]
cov_ext <- cov_tar * scale_target
```

Now generate the predictors:

```{r}
xtar <- matrix(rnorm(n_tar * d), ncol = d) %*%  chol(cov_tar)
xext <- matrix(rnorm(n_ext * d), ncol = d) %*%  chol(cov_ext)
```

Now calculate the linear predictors ($X_i^\top \beta$ or
$X_i^\top(\beta+\gamma)$). The true value of $\beta$ is $\beta=0$ (without loss of
generality because we're not shrinking $\beta$ toward zero), and the true value
of $\gamma$ is the evenly spaced sequence of numbers from $-c$ to $c$ for some
value $c$. The true intercept is 0 for both the target and the external
populations, i.e. there is no actual bias in the intercept.
```{r}
betas <- numeric(d);
gammas <- 0.5*seq(-1, 1, length = d)
lp_tar <- drop(xtar %*% betas);
lp_ext <- drop(xext %*% (betas + gammas))
```

We will use these linear predictors to generate binomial and time-to-event outcomes. 
Here are the binomial outcomes:

```{r}
ytar_bin <- rbinom(n_tar, size = 1, prob = plogis(lp_tar))
yext_bin <- rbinom(n_ext, size = 1, prob = plogis(lp_ext))
```

And here are the time-to-event outcomes with about 20\% censoring:

```{r}
set.seed(1);
time_ytar <- rexp(n_tar, exp(lp_tar))
time_yext <- rexp(n_ext, exp(lp_ext))
cens_ytar <- rexp(n_tar, 0.25 * mean(exp(lp_tar)))
cens_yext <- rexp(n_ext, 0.25 * mean(exp(lp_ext)))
ytar_te = Surv(pmin(time_ytar, cens_ytar), 1*(time_ytar < cens_ytar))
yext_te = Surv(pmin(time_yext, cens_yext), 1*(time_yext < cens_yext))
```



## binomial outcomes, `n_tar = 50`, `n_ext = 5000`


Both of these should give equivalent results to our method using $\lambda = 0$:
```{r}
n_tar_subsample = 50;
n_ext_subsample = 5000;
glm_nopool <- 
  glm(ytar_bin[1:n_tar_subsample] ~ xtar[1:n_tar_subsample,],
      family = "binomial") %>%
  coef() 
glmnet_nopool <- 
  glmnet(x = xtar[1:n_tar_subsample,], 
         y = ytar_bin[1:n_tar_subsample], 
         alpha = 0,  
         family = "binomial", 
         lambda = 0) %>%
  coef() %>% 
  drop()
```

This is the DEGLR method with two values of $\lambda$: $\lambda \approx 0$ and $\lambda$ very large:
```{r}
deglr_mod <- 
  deglr(xtar = xtar[1:n_tar_subsample,], 
        ytar = ytar_bin[1:n_tar_subsample], 
        xext = xext[1:n_ext_subsample,], 
        yext = yext_bin[1:n_ext_subsample], 
        family = "binomial", 
        standardize = TRUE, 
        nlambda = 50,
        lambda.min.ratio = 1e-20,
        return_only_at = c(1e-20, 1e3),
        thresh = 1e-7, maxit = 1e5)

```

This should give equivalent results to $\lambda$ very large:
```{r}
glm_pool <- 
  glm(c(ytar_bin[1:n_tar_subsample], 
        yext_bin[1:n_ext_subsample]) ~ rbind(xtar[1:n_tar_subsample,], 
                                             xext[1:n_ext_subsample,]),
      family = "binomial") %>%
  coef()
```


```{r, echo = FALSE}
tibble(var_name = names(glmnet_nopool), 
       true_value = c(0, betas),
       glm_nopool = glm_nopool, 
       glmnet_nopool = glmnet_nopool, 
       deglr_nopool = deglr_mod$beta_hat[,1],
       deglr_pool = deglr_mod$beta_hat[,2],
       glm_pool = glm_pool) %>%
  kable(caption = glue("Comparison of estimates of $\\beta$ with a binomial outcome, {n_tar_subsample} samples
  from the target population, and {n_ext_subsample} samples from the external
  population. The 'nopool' methods 
  should be identical to eacho ther, and the 'pool' methods should be identical to
  each other."))
```



## binomial outcomes, `n_tar = 1000`, `n_ext = 1000`


Both of these should give equivalent results to our method using $\lambda = 0$:
```{r}
n_tar_subsample = 1000;
n_ext_subsample = 1000;
glm_nopool <-
  glm(ytar_bin[1:n_tar_subsample] ~ xtar[1:n_tar_subsample,], 
      family = "binomial") %>% 
  coef() 
glmnet_nopool <- 
  glmnet(x = xtar[1:n_tar_subsample,], 
         y = ytar_bin[1:n_tar_subsample],
         alpha = 0, 
         family = "binomial",
         lambda = 0) %>%
  coef() %>% 
  drop()
```

This is the DEGLR method with two values of $\lambda$: $\lambda \approx 0$ and $\lambda$ very large:
```{r}
deglr_mod <- 
  deglr(xtar = xtar[1:n_tar_subsample,], 
        ytar = ytar_bin[1:n_tar_subsample], 
        xext = xext[1:n_ext_subsample,], 
        yext = yext_bin[1:n_ext_subsample], 
        family = "binomial", 
        standardize = TRUE, 
        nlambda = 50,
        lambda.min.ratio = 1e-20,
        return_only_at = c(1e-30, 1e3),
        thresh = 1e-7, maxit = 1e5)
```

This should give equivalent results to $\lambda$ very large:
```{r}
glm_pool <- 
  glm(c(ytar_bin[1:n_tar_subsample],
        yext_bin[1:n_ext_subsample]) ~ rbind(xtar[1:n_tar_subsample,],
                                             xext[1:n_ext_subsample,]),
      family = "binomial") %>% 
  coef()
```


```{r, echo = FALSE}
tibble(var_name = names(glmnet_nopool), 
       true_value = c(0, betas),
       glm_nopool = glm_nopool, 
       glmnet_nopool = glmnet_nopool, 
       deglr_nopool = deglr_mod$beta_hat[,1],
       deglr_pool = deglr_mod$beta_hat[,2],
       glm_pool = glm_pool) %>%
  kable(caption = glue("Comparison of estimates of $\\beta$ with a binomial outcome, {n_tar_subsample} samples
  from the target population, and {n_ext_subsample} samples from the external
  population. The 'nopool' methods 
  should be identical to eacho ther, and the 'pool' methods should be identical to
  each other."))
```



## time-to-event outcomes,  `n_tar = 50`, `n_ext = 5000`

Both of these should give equivalent results to our method using $\lambda = 0$:
```{r}
n_tar_subsample = 50;
n_ext_subsample = 5000;
coxph_nopool <- 
  coxph(ytar_te[1:n_tar_subsample] ~ xtar[1:n_tar_subsample,]) %>%
  coef()
glmnet_nopool <- 
  glmnet(x = xtar[1:n_tar_subsample,], 
         y = ytar_te[1:n_tar_subsample], 
         alpha = 0,  
         family = "cox", 
         lambda = 0) %>% 
  coef() %>% 
  drop()
```


This is the DEGLR method with two values of $\lambda$: $\lambda \approx 0$ and $\lambda$ very large:
```{r}
deglr_mod <- 
  deglr(xtar = xtar[1:n_tar_subsample,], 
        ytar = ytar_te[1:n_tar_subsample], 
        xext = xext[1:n_ext_subsample,], 
        yext = yext_te[1:n_ext_subsample], 
        family = "cox", 
        standardize = TRUE, 
        nlambda = 50,
        lambda.min.ratio = 1e-20,
        return_only_at = c(1e-30, 1e3),
        thresh = 1e-7, maxit = 1e5)

```

This should give equivalent results to $\lambda$ very large:
```{r}
coxph_pool <- 
  coxph(c(ytar_te[1:n_tar_subsample], 
          yext_te[1:n_ext_subsample]) ~ rbind(xtar[1:n_tar_subsample,], 
                                              xext[1:n_ext_subsample,])) %>% 
  coef()
```


```{r, echo = FALSE}
tibble(var_name = names(glmnet_nopool), 
       true_value = betas,
       coxph_nopool = coxph_nopool, 
       glmnet_nopool = glmnet_nopool, 
       deglr_nopool = deglr_mod$beta_hat[,1],
       deglr_pool = deglr_mod$beta_hat[,2],
       coxph_pool = coxph_pool) %>%
  kable(caption = glue("Comparison of estimates of $\\beta$ with a time-to-event outcome, {n_tar_subsample} samples
  from the target population, and {n_ext_subsample} samples from the external
  population. The 'nopool' methods 
  should be identical to eacho ther, and the 'pool' methods should be identical to
  each other."))
```


## time-to-event outcomes,  `n_tar = 1000`, `n_ext = 1000`

Both of these should give equivalent results to our method using $\lambda = 0$:
```{r}
n_tar_subsample = 1000;
n_ext_subsample = 1000;
coxph_nopool <- 
  coxph(ytar_te[1:n_tar_subsample] ~ xtar[1:n_tar_subsample,]) %>% 
  coef()
glmnet_nopool <- 
  glmnet(x = xtar[1:n_tar_subsample,], 
         y = ytar_te[1:n_tar_subsample], 
         alpha = 0,  
         family = "cox", 
         lambda = 0) %>% 
  coef() %>% 
  drop()
```


This is the DEGLR method with two values of $\lambda$: $\lambda \approx 0$ and $\lambda$ very large:
```{r}
deglr_mod <- 
  deglr(xtar = xtar[1:n_tar_subsample,], 
        ytar = ytar_te[1:n_tar_subsample], 
        xext = xext[1:n_ext_subsample,], 
        yext = yext_te[1:n_ext_subsample], 
        family = "cox", 
        standardize = TRUE, 
        nlambda = 50,
        lambda.min.ratio = 1e-20,
        return_only_at = c(1e-30, 1e3),
        thresh = 1e-7, maxit = 1e5)

```

This should give equivalent results to $\lambda$ very large:
```{r}
coxph_pool <- 
  coxph(c(ytar_te[1:n_tar_subsample],
          yext_te[1:n_ext_subsample]) ~ rbind(xtar[1:n_tar_subsample,], 
                                              xext[1:n_ext_subsample,])) %>%
  coef()
```


```{r, echo = FALSE}
tibble(var_name = names(glmnet_nopool), 
       true_value = betas,
       coxph_nopool = coxph_nopool, 
       glmnet_nopool = glmnet_nopool, 
       deglr_nopool = deglr_mod$beta_hat[,1],
       deglr_pool = deglr_mod$beta_hat[,2],
       coxph_pool = coxph_pool) %>%
  kable(caption = glue("Comparison of estimates of $\\beta$ with a time-to-event outcome, {n_tar_subsample} samples
  from the target population, and {n_ext_subsample} samples from the external
  population. The 'nopool' methods 
  should be identical to eacho ther, and the 'pool' methods should be identical to
  each other."))
```

## Summary

When the sample size ratio is large in favor of the external population, the DELGR
algorithm doesn't give the right answer when $\lambda\approx 0$, particularly
so for time-to-event outcomes. I think this must be because
the observations from the external population are dominating the log-likelihood
and so small changes in beta don't matter as much. 

Changing the convergence threshold (`thresh` in `glmnet`) doesn't seem to have an
impact. 

```{r, echo = FALSE}
if(0) {
  
  
  nfolds = 5;
  ncvreps = 10;
  nlambda = 20;
  lambda.min.ratio = 1e-8;
  fixed_lambda_seq = NULL
  L = NULL;
  standardize = TRUE;
  thresh = 1e-7;
  maxit = 1e5
  
  foo = cv_deglr(xtar = xtar, 
                 ytar = ytar_te, 
                 xext = xext, 
                 yext = yext_te, 
                 family = family, 
                 nfolds = nfolds, 
                 ncvreps = ncvreps, 
                 nlambda = nlambda)
  
  foo$beta_hat
  sqrt(mean(foo$beta_hat^2))
  sqrt(mean(coef(glmnet(x = xtar, y = ytar_te, alpha = 0,  family = family, lambda = 0))^2))
  foo$lambda_opt
}

if(0) {
  foo = deglr(xtar = xtar, ytar = ytar_te, xext = xext, yext = yext_te, family = family, lambda = c(0), standardize = TRUE, thresh = 1e-7, maxit = 1e5)
  lp_aug = c(numeric(n_tar),(cbind(1, xext) %*% foo$gamma_hat))
  if(family == "binomial") {
    glm(c(ytar_bin, yext_bin) ~ rbind(xtar, xext) + offset(lp_aug), family = "binomial") %>% coef() %>% print()
  } else if (family == "cox") {
    coxph(c(ytar_te, yext_te) ~ rbind(xtar, xext) + offset(lp_aug)) %>% coef() %>% print()
  }
  foo$beta_hat
}
```




